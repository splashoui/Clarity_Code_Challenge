# Clarity_Code_Challenge

### Challenge description
A log file contains newline-terminated, space-separated text formatted like: <unix_timestamp> <hostname> <hostname>

For example:

>1366815793 quark garak    
>1366815795 brunt quark    
>1366815811 lilac garak  

Each line represents connection from a host (left) to another host (right) at a given time. The lines are roughly sorted by timestamp. They might be out of order by maximum 5 minutes.Implement a tool that parse log files like these, we provide you a input Data
Example.
## Goals to Achieve
### 1. Parse the data with a time_init, time_end
Build a tool, that given the name of a file (with the format described above), an
init_datetime , an end_datetime, and a Hostname, returns:
* A list of hostnames connected to the given host during the given period.

## 2. Unlimited Input Parser
The tool should both parse previously written log files and terminate or collect input from a
new log file while it's being written and run indefinitely.
The script will output, once every hour:  
* A list of hostnames connected to a given (configurable) host during the last hour.   
* A list of hostnames received connections from a given (configurable) host during the last
hour.   
* The hostname that generated most connections in the last hour.

### Requirements

Python 3.0 or higher.

>Note : In this project, only standart libraries has been used. So, for this reason, requirements.txt file is empty.

Use the package manager [pip](https://pip.pypa.io/en/stable/) to install required package.

```bash
pip install -r requirements.txt
```
  
## How to run

We can run the program from the terminal inside the correct project the directory by running: 
```bash
$ python main.py
```   
  
>C:\Users\kurum\Desktop\Clarity_Code_Challenge>python main.py
  
When we run the main program, main program will provide 3 options to the user:
  
* (0)- Quit
* (1)- Normal Parser
* (2)- Unlimited Parser

Based on the input of the user, it will request the required inputs from the user:

- - - -
  
### 1- Normal Parser 
  
    Parameters
        ----------
            init_time : int
                initial time of the period
            end_time : int
                end time of the period
            host_name : str
                the name of the host
        ----------  

After taking the inputs above from the user, the main program will call `ParserHostConnection` class and its method `run_store_in_logs()` from the parser.py file.
Thanks to `self.init_time`, `self.end_time`, `self.host_name variables`, we can use these inputs in `ParserHostConnection` class, the inputs are taken from the user in the main program.
  
Inside the method `run_store_in_logs()`, this method calls another method named `create_list_of_hosts_to_connected()`.
  
In the `create_list_of_hosts_to_connected()` method, it reads the input text file, it reads each line one by one, and it uses the input variables taken from the user before to filter the data to find the connections generated to the input host name during the given time period.
  
After finding the connections, it stores these filtered connections in an empty list `listed_information_to` to read the list later.
  
After this, in `run_store_in_logs()` method, it checks if the list `listed_information_to` is empty or not.
  
In the case the list is not empty, it prints the information, how many connections were realized to the given host during the given time period, and which are the connections.
  
Just after this, it stores the connections found in a log file under the 'logs/parsed_host_list_files' folder with the name of the file      'inittime_endtime_hostname.txt'
  
In the case that any connections could not be found to the given hostname during the given time period, it prints the information that there is not any host connected to the given host during the given period.
Just after this, it stores the error in an error log file under 'logs/error_logs' folder with the name  'failed_inittime_endtime_hostname.txt'
  
- - - -
  
### 2- Unlimited Parser

    Checks to connections generated by the input host name or connections realized to the input host name during the last hour.
    
    Parameters
        ----------
            host_name : str
                the name of the host
        ----------
    
In the case that the user selects option 2 since the time period is defined, during the last hour. The user is being requested to give only one input which is the host_name.
  
After taking the host name input from the user, the main program will call `UnlimitedParserHostConnection` class and its method `last_one_hour_parse()` from unlimited_parser.py file.
Thanks to self.host_name variable, we can use these inputs in UnlimitedParserHostConnection class, the input taken from the user in the main program.

In `last_one_hour_parse()` method, it defines the current time and an hour ago in the format of UNIX timestamp in milliseconds which is 13 digits time stamp.  
After defining init_time and end_time,  
  
It calls the method `hosts_connected_to_input_host()` in the same class to call `create_list_of_hosts_to_connected()` method from `ParserHostConnection` class to filter the connections to the given host name during the last hour.  
    
It calls the `hosts_recieved_connection_from_input_host()` in the same class to call `create_list_of_hosts_from_connected()` method from `ParserHostConnection` class to filter the **connections generated by the given host name** during the last hour.
  
After we get the list of connections generated by the host name and the connections realized to the host name, in the method `last_one_hour_parse()` 
it assigns this information to `host_connected`, `host_received` variables and later on prints the connections in the case that connections found during the last hour.
In the case that there is not any connections found during last hour, it prints information below: 
  
**The host "host_name" has not connected to any hosts during the last hour.**
  
**There is no any host connected to the host "host_name" during the last hour.**
  

#### Note1: 

You can change the file_path variable in order to work with another input file.

>file_path = 'input_file/input-file-10000.txt'

### Test Case

To create tests, I have used unittest library of Python.
  
To test the cases, run the command below in terminal inside the project directory.

```bash 
$ python normal_parser_test.py
```
Test cases:
  
1. `def test_output_normal_parser`: Tests whether expected output is the same with the result for given time period and hostname.
2. `def test_host_name_all_lower_letters`: Tests whether expected output is the same with the result in the case that the user gives host_name all lower letters.
3. `def test_host_name_all_capital_letters`: Tests whether expected output is the same with the result in the case that the user gives host_name all CAPITAL letters.
4. `def test_log_file`: Tests that if the log file has been created correctly with the correct name.
5. `def test_error_log_file`: Test that if the error log file has been created with the correct name.
6. `def test_information_stored`: To check if the information has been stored in the log file. If the log file is empty or not.

### What is missing?
  
I could not make it work the following task:  
>The tool should both parse previously written log files and terminate or collect input from a new log file while it's being written and run indefinitely.
  
My unlimited_parser program just defines the current time and an hour ago and filters the connections realized to and by the given host name.
I really want to make it so it can collect input from a new log file while it's being written, I have to do more research on how to do it without any external libraries. 
  
I should have tested the program better and smarter for more edge cases.
I should have built the unlimited parser correctly.
 
### Personal note:

I believe that I have never experienced working on a real project which must to be built carefully based on fully and well structured, tested for edge cases, the code easy to extend or maintain, performs well.
  
I have tried my best to create this project. I have tried to build the project well structured as much as possible I could.  

I clearly understand the points these points:    
  
1. When testing something, we generally account for potential cases where our app could fail (edge cases). Testing is about checking for certain conditions in our app and seeing how it handles them. This was my first time, testing a program. I believe that It will be better next time.
  
2. Would it be easy to maintain and comprehend? Will I be able to understand the code 2 years in the future, when I may no longer be doing Python or programming at all? This generally comes in the form of documenting my code so that others understand why I did x or what x does. Docstrings and comments are two good ways to document code which I have tried to explain most of the steps in my codes and tried to use Docstrings for my methods under the classes.

